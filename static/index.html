<!DOCTYPE html>
<html>
<head>
  <title>RL Car Simulation</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body.dark {
      background: #1e1e1e;
      color: #f5f5f5;
    }
    body.dark label,
    body.dark output {
      color: #f5f5f5;
    }
    body.dark #plot {
      background: #333333;
    }

    #app {
      display: flex;
      align-items: flex-start;
      padding: 20px;
    }
    #controls {
      width: 300px;
      padding: 1rem;
    }
    #plot {
      width: 700px;
      height: 450px;
      margin-left: 20px;
    }

    label { display: block; margin-top: 10px; }
    output { margin-left: 10px; font-weight: bold; }
    #themeToggle {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 6px 12px;
      cursor: pointer;
    }
    #controls button {
      margin-top: 15px;
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <button id="themeToggle">üåô Dark Mode</button>
  <div id="app">
    <div id="controls">
      <h2>Car Simulator</h2>

      <label>Friction:
        <input type="range" id="friction" min="0" max="1.0" step="0.01" value="0.7" oninput="fDisplay.value = friction.value">
        <output id="fDisplay">0.7</output>
      </label>

      <label>Gas Sensitivity:
        <input type="range" id="gas_sensitivity" min="0" max="2.0" step="0.01" value="0.9" oninput="gDisplay.value = gas_sensitivity.value">
        <output id="gDisplay">0.9</output>
      </label>

      <label>Brake Sensitivity:
        <input type="range" id="brake_sensitivity" min="0" max="2.0" step="0.01" value="0.4" oninput="bDisplay.value = brake_sensitivity.value">
        <output id="bDisplay">0.4</output>
      </label>

      <label>Steer Sensitivity:
        <input type="range" id="steer_sensitivity" min="0" max="0.5" step="0.01" value="0.1" oninput="sDisplay.value = steer_sensitivity.value">
        <output id="sDisplay">0.1</output>
      </label>

      <label>Path Type:
        <select id="path_type">
          <option value="sine">Sine</option>
          <option value="straight">Straight</option>
          <option value="alternating">Alternating</option>
        </select>
      </label>

      <button id="showPathBtn">Reset</button>
      <button id="modeToggle">üéÆ Manual Mode</button>

      <div id="simulateContainer">
        <button onclick="simulate()" id="simulateBtn">Simulate</button>
        <button id="resetBtn">Reset to Defaults</button>
        <div id="spinner" style="display:none; margin-top: 10px;">‚è≥ Simulating...</div>
      </div>      
    </div>

    <div id="plot"></div>
  </div>

<script>
  const themeToggle = document.getElementById('themeToggle');
  themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('dark');
    themeToggle.textContent = document.body.classList.contains('dark') ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
  });

  let animationInterval = null;
  let currentPath = [];
  let currentWaypoints = [];

  async function showPathOnly(path_type) {
    const res = await fetch("/get_path", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ path_type })
    });
    const data = await res.json();

    currentPath = data.path;
    currentWaypoints = data.waypoints || [];

    const plotData = [
      {
        x: currentPath.map(p => p[0]),
        y: currentPath.map(p => p[1]),
        mode: 'lines',
        name: 'Path',
        line: { dash: 'dot', width: 2, color: 'gray' }
      },
      {
        x: [],
        y: [],
        mode: 'lines+markers',
        name: 'Car',
        line: { color: 'blue', width: 2 },
        marker: { size: 6 }
      },
      {
        x: currentWaypoints.map(p => p[0]),
        y: currentWaypoints.map(p => p[1]),
        mode: 'markers',
        name: 'Waypoints',
        marker: { color: 'red', size: 10, symbol: 'cross' }
      }
    ];

    Plotly.newPlot('plot', plotData, {
      margin: { t: 20, b: 40, l: 40, r: 20 },
      xaxis: { title: "X" },
      yaxis: { title: "Y", scaleanchor: "x" }
    });
  }

  // Show Path Only (Reset) Button
  document.getElementById("showPathBtn").addEventListener("click", () => {
    if (animationInterval) {
      clearInterval(animationInterval);
      animationInterval = null;
    }
    document.getElementById("spinner").style.display = "none";
    const path_type = document.getElementById("path_type").value;
    showPathOnly(path_type);

    simulateBtn.disabled = false; // re-enable simulate button
  });


  // Reset to Defaults
  document.getElementById("resetBtn").addEventListener("click", () => {
    document.getElementById("friction").value = 0.7;
    document.getElementById("gas_sensitivity").value = 0.9;
    document.getElementById("brake_sensitivity").value = 0.4;
    document.getElementById("steer_sensitivity").value = 0.1;
    fDisplay.value = 0.7;
    gDisplay.value = 0.9;
    bDisplay.value = 0.4;
    sDisplay.value = 0.1;

    // No animation reset here
  });

  // Manual Mode Toggle
  let isManualMode = false;
  const modeToggle = document.getElementById('modeToggle');
  const simulateBtn = document.getElementById('simulateBtn');

  // Key state tracking for WASD
  const keysPressed = {
    w: false,
    a: false,
    s: false,
    d: false,
  };

  window.addEventListener('keydown', (e) => {
    if (!isManualMode) return; // Only track keys in manual mode
    switch(e.key.toLowerCase()) {
      case 'w': keysPressed.w = true; e.preventDefault(); break;
      case 'a': keysPressed.a = true; e.preventDefault(); break;
      case 's': keysPressed.s = true; e.preventDefault(); break;
      case 'd': keysPressed.d = true; e.preventDefault(); break;
    }
  });

  window.addEventListener('keyup', (e) => {
    if (!isManualMode) return;
    switch(e.key.toLowerCase()) {
      case 'w': keysPressed.w = false; e.preventDefault(); break;
      case 'a': keysPressed.a = false; e.preventDefault(); break;
      case 's': keysPressed.s = false; e.preventDefault(); break;
      case 'd': keysPressed.d = false; e.preventDefault(); break;
    }
  });

  // Controls to disable during 1-second cooldown
  const buttonsToDisable = [
    document.getElementById('showPathBtn'),
    document.getElementById('modeToggle'),
    document.getElementById('resetBtn'),
    document.getElementById('path_type'),
    document.getElementById('friction'),
    document.getElementById('gas_sensitivity'),
    document.getElementById('brake_sensitivity'),
    document.getElementById('steer_sensitivity'),
  ];

  function setControlsDisabled(state) {
    buttonsToDisable.forEach(el => el.disabled = state);
  }

  // Manual mode car state and controls
  let carState = {
    x: 0,
    y: 0,
    heading: 0, // angle in radians, 0 = right
    velocity: 0,
    steerAngle: 0,
  };

  let gas = 0;
  let brake = 0;
  let steer = 0;

  // Constants for control update speed and limits
  const GAS_STEP = 0.05;
  const BRAKE_STEP = 0.05;
  const STEER_STEP = 0.03;
  const STEER_RETURN_STEP = 0.02;
  const GAS_MAX = 1.0;
  const BRAKE_MAX = 1.0;
  const STEER_MAX = 0.5;
  const STEER_MIN = -0.5;

  function updateControls() {
    if (keysPressed.w) {
      gas = Math.min(gas + GAS_STEP, GAS_MAX);
    } else {
      gas = Math.max(gas - GAS_STEP, 0);
    }

    if (keysPressed.s) {
      brake = Math.min(brake + BRAKE_STEP, BRAKE_MAX);
    } else {
      brake = Math.max(brake - BRAKE_STEP, 0);
    }

    if (keysPressed.a && !keysPressed.d) {
      steer = Math.min(steer + STEER_STEP, STEER_MAX);
    } else if (keysPressed.d && !keysPressed.a) {
      steer = Math.max(steer - STEER_STEP, STEER_MIN);
    } else {
      if (steer > 0) {
        steer = Math.max(steer - STEER_RETURN_STEP, 0);
      } else if (steer < 0) {
        steer = Math.min(steer + STEER_RETURN_STEP, 0);
      }
    }

      console.log("Gas:", gas, "Brake:", brake, "Steer:", steer); // üëà You add this line

  }

  // Simple car physics update for manual mode
  function updateCarState(friction, gasSensitivity, brakeSensitivity, steerSensitivity) {
    // Update velocity: velocity += gas * gasSensitivity - brake * brakeSensitivity - friction * velocity
    // Clamp velocity >= 0

    const acceleration = gas * gasSensitivity - brake * brakeSensitivity;
    carState.velocity += acceleration;
    carState.velocity -= friction * carState.velocity;
    if (carState.velocity < 0) carState.velocity = 0;

    // Update steering angle
    carState.steerAngle = steer * steerSensitivity;

    // Update heading based on steer angle and velocity
    // Simple bicycle model approximation: change heading proportional to steer angle and velocity
    const turnRate = carState.steerAngle * carState.velocity * 0.1; // 0.1 is a tuning parameter
    carState.heading += turnRate;

    // Update position
    carState.x += Math.cos(carState.heading) * carState.velocity * 0.1; // 0.1 scales speed for visualization
    carState.y += Math.sin(carState.heading) * carState.velocity * 0.1;
  }

  let manualAnimationInterval = null;

async function startManualSimulation() {
  // 1) Read controls
const frictionSlider      = document.getElementById("friction");
const gasSensSlider       = document.getElementById("gas_sensitivity");
const brakeSensSlider     = document.getElementById("brake_sensitivity");
const steerSensSlider     = document.getElementById("steer_sensitivity");
const pathTypeSelect      = document.getElementById("path_type");

const friction         = parseFloat(frictionSlider.value);
const gas_sensitivity  = parseFloat(gasSensSlider.value);
const brake_sensitivity= parseFloat(brakeSensSlider.value);
const steer_sensitivity= parseFloat(steerSensSlider.value);
const path_type        = pathTypeSelect.value;


  // 2) Initialize server‚Äêside env
  const res = await fetch("/manual_start", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      friction,
      gas_sensitivity,
      brake_sensitivity,
      steer_sensitivity,
      path_type
    })
  });
  const { observation } = await res.json();

  // 3) Plot initial car position
  //    (we assume showPathOnly() has already drawn the path & waypoints)
  Plotly.deleteTraces('plot', 1);
  Plotly.addTraces('plot', {
    x: [observation[0]],
    y: [observation[1]],
    mode: 'lines+markers',
    name: 'Car',
    line: { width: 2 },
    marker: { size: 6 }
  });

  // 4) Kick off manual loop
  if (manualAnimationInterval) clearInterval(manualAnimationInterval);
  manualAnimationInterval = setInterval(async () => {
    updateControls();  // this updates your gas/brake/steer globals

    const stepRes = await fetch("/manual_step", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ gas, brake, steer })
    });
    const data = await stepRes.json();
    if (data.error) {
      console.error(data.error);
      clearInterval(manualAnimationInterval);
      return;
    }

    Plotly.extendTraces('plot', {
      x: [[data.observation[0]]],
      y: [[data.observation[1]]]
    }, [1]);

    if (data.terminated || data.truncated) {
      clearInterval(manualAnimationInterval);
      console.log("Manual episode ended");
    }
  }, 50);
}



  modeToggle.addEventListener('click', () => {
    if (animationInterval) {
      clearInterval(animationInterval);
      animationInterval = null;
    }
    if (manualAnimationInterval) {
      clearInterval(manualAnimationInterval);
      manualAnimationInterval = null;
    }

    document.getElementById("spinner").style.display = "none";

    const path_type = document.getElementById("path_type").value;
    showPathOnly(path_type);

    isManualMode = !isManualMode;

    if (isManualMode) {
      modeToggle.textContent = 'ü§ñ Auto Mode';
      simulateBtn.disabled = true;
      console.log('‚úÖ Manual Mode Activated');
      startManualSimulation();
    } else {
      modeToggle.textContent = 'üéÆ Manual Mode';
      simulateBtn.disabled = false;
      console.log('‚úÖ Auto Mode Activated');
    }
  });

  // Simulate function (auto mode)
  async function simulate() {
    if (animationInterval) {
      clearInterval(animationInterval);
      animationInterval = null;
    }
    if (manualAnimationInterval) {
      clearInterval(manualAnimationInterval);
      manualAnimationInterval = null;
    }

    // Disable other controls immediately
    setControlsDisabled(true);
    simulateBtn.disabled = true;

    document.getElementById("spinner").style.display = "block";

    const friction = parseFloat(document.getElementById("friction").value);
    const gas_sensitivity = parseFloat(document.getElementById("gas_sensitivity").value);
    const brake_sensitivity = parseFloat(document.getElementById("brake_sensitivity").value);
    const steer_sensitivity = parseFloat(document.getElementById("steer_sensitivity").value);
    const path_type = document.getElementById("path_type").value;

    await showPathOnly(path_type);

    const res = await fetch("/simulate", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        friction,
        gas_sensitivity,
        brake_sensitivity,
        steer_sensitivity,
        path_type
      })
    });

    const data = await res.json();
    const car = data.car;

    // Re-enable controls after 1 second
    setTimeout(() => setControlsDisabled(false), 1000);

    let idx = 0;
    const maxIdx = car.length;

    animationInterval = setInterval(() => {
      if (idx >= maxIdx) {
        clearInterval(animationInterval);
        animationInterval = null;
        document.getElementById("spinner").style.display = "none";
        simulateBtn.disabled = false;
        return;
      }
      Plotly.extendTraces('plot', {
        x: [[car[idx][0]]],
        y: [[car[idx][1]]]
      }, [1]);
      idx++;
    }, 50);
  }

  // Initial load
  showPathOnly(document.getElementById("path_type").value);
</script>
</body>
</html>
