<!DOCTYPE html>
<html>
<head>
  <title>RL Car Simulation</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    /* Dark‚Äëmode styles */
    body.dark {
      background: #1e1e1e;
      color: #f5f5f5;
    }
    body.dark label,
    body.dark output {
      color: #f5f5f5;
    }
    body.dark #plot {
      background: #333333;
    }

    /* Layout */
    #app {
      display: flex;
      align-items: flex-start;
      padding: 20px;
      box-sizing: border-box;
    }
    #controls {
      width: 300px;
      padding: 1rem;
      box-sizing: border-box;
    }
    #plot {
      width: 700px;
      height: 450px;
      margin-left: 20px;
      background: transparent;
    }

    /* Original styles */
    label { display: block; margin-top: 10px; }
    output { margin-left: 10px; font-weight: bold; }
    #themeToggle {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 6px 12px;
      cursor: pointer;
    }
    #controls button {
      margin-top: 15px;
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <button id="themeToggle">üåô Dark Mode</button>
  <div id="app">
    <div id="controls">
      <h2>Car Simulator</h2>

      <label>Friction:
        <input type="range" id="friction" min="0" max="1.0" step="0.01" value="0.7" oninput="fDisplay.value = friction.value">
        <output id="fDisplay">0.7</output>
      </label>

      <label>Gas Sensitivity:
        <input type="range" id="gas_sensitivity" min="0" max="2.0" step="0.01" value="0.9" oninput="gDisplay.value = gas_sensitivity.value">
        <output id="gDisplay">0.9</output>
      </label>

      <label>Brake Sensitivity:
        <input type="range" id="brake_sensitivity" min="0" max="2.0" step="0.01" value="0.4" oninput="bDisplay.value = brake_sensitivity.value">
        <output id="bDisplay">0.4</output>
      </label>

      <label>Steer Sensitivity:
        <input type="range" id="steer_sensitivity" min="0" max="0.5" step="0.01" value="0.1" oninput="sDisplay.value = steer_sensitivity.value">
        <output id="sDisplay">0.1</output>
      </label>

      <label>Path Type:
        <select id="path_type">
          <option value="sine">Sine</option>
          <option value="straight">Straight</option>
          <option value="alternating">Alternating</option>
        </select>
      </label>
      <button id="showPathBtn">Reset</button>

      <button id="modeToggle">üéÆ Manual Mode</button>
      <!-- <button onclick="simulate()" id="simulateBtn">Simulate</button>
      <span id="loadingSpinner" style="display:none; margin-left:10px;">‚è≥ Simulating...</span> -->
      <div id="simulateContainer">
        <button onclick="simulate()" id="simulateBtn">Simulate</button>
        <button id="resetBtn">Reset to Defaults</button>
        <div id="spinner" style="display:none; margin-top: 10px;">‚è≥ Simulating...</div>
      </div>      
    </div>

    <div id="plot"></div>
  </div>
  

<script>
  // Theme toggle
  const themeToggle = document.getElementById('themeToggle');
  themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('dark');
    themeToggle.textContent = document.body.classList.contains('dark')
      ? '‚òÄÔ∏è Light Mode'
      : 'üåô Dark Mode';
  });

  let animationInterval = null;
  let currentPath = [];
  let currentWaypoints = [];

  // Reusable function to show path and waypoints only
  async function showPathOnly(path_type) {
    // Stop ongoing animation
    if (animationInterval) {
      clearInterval(animationInterval);
      animationInterval = null;
      console.log('‚èπ Simulation stopped by Show Path Only');
    }

    // Fetch path only from backend
    const res = await fetch("/get_path", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ path_type })
    });
    const data = await res.json();

    currentPath = data.path;
    currentWaypoints = data.waypoints || [];

    // Plot path and waypoints only
const plotData = [
  {
    x: currentPath.map(p => p[0]),
    y: currentPath.map(p => p[1]),
    mode: 'lines',
    name: 'Path',
    line: { dash: 'dot', width: 2, color: 'gray' }
  },
  {
    x: [],  // car trace empty here ‚Äî will be added in simulate
    y: [],
    mode: 'lines+markers',
    name: 'Car',
    line: { color: 'blue', width: 2 },
    marker: { size: 6 }
  },
  {
    x: currentWaypoints.map(p => p[0]),
    y: currentWaypoints.map(p => p[1]),
    mode: 'markers',
    name: 'Waypoints',
    marker: { color: 'red', size: 10, symbol: 'cross' }
  }
];


    Plotly.newPlot('plot', plotData, {
      margin: { t: 20, b: 40, l: 40, r: 20 },
      xaxis: { title: "X" },
      yaxis: { title: "Y", scaleanchor: "x" }
    });
  }

  // Show Path Only button
  document.getElementById("showPathBtn").addEventListener("click", () => {
    const path_type = document.getElementById("path_type").value;
    showPathOnly(path_type);
  });

  // Manual mode toggle
  let isManualMode = false;

  const modeToggle = document.getElementById('modeToggle');
  const simulateBtn = document.getElementById('simulateBtn');

modeToggle.addEventListener('click', () => {
  // Stop ongoing simulation
  if (animationInterval) {
    clearInterval(animationInterval);
    animationInterval = null;
    console.log('‚èπ Simulation stopped');
  }

  // Call Show Path Only to clear and redraw path/waypoints
  showPathOnly();

  isManualMode = !isManualMode;

  if (isManualMode) {
    modeToggle.textContent = 'ü§ñ Auto Mode';
    simulateBtn.disabled = true;
    console.log('‚úÖ Manual Mode Activated');
    // TODO: Start manual control logic here
  } else {
    modeToggle.textContent = 'üéÆ Manual Mode';
    simulateBtn.disabled = false;
    console.log('‚úÖ Auto Mode Activated');
    // TODO: Cleanup manual control here
  }
});

  // Main simulation function
  async function simulate() {
    if (animationInterval) {
      clearInterval(animationInterval);
      animationInterval = null;
    }

    document.getElementById("spinner").style.display = "block"; // üëà show

    const friction        = parseFloat(document.getElementById("friction").value);
    const gas_sensitivity = parseFloat(document.getElementById("gas_sensitivity").value);
    const brake_sensitivity = parseFloat(document.getElementById("brake_sensitivity").value);
    const steer_sensitivity = parseFloat(document.getElementById("steer_sensitivity").value);
    const path_type       = document.getElementById("path_type").value;

    await showPathOnly(path_type);

    const res = await fetch("/simulate", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        friction,
        gas_sensitivity,
        brake_sensitivity,
        steer_sensitivity,
        path_type
      })
    });

    const data = await res.json();
    const car  = data.car;

    let idx = 0;
    const maxIdx = car.length;

    animationInterval = setInterval(() => {
      if (idx >= maxIdx) {
        clearInterval(animationInterval);
        animationInterval = null;
        document.getElementById("spinner").style.display = "none"; // üëà hide
        return;
      }
      Plotly.extendTraces('plot', {
        x: [[car[idx][0]]],
        y: [[car[idx][1]]]
      }, [1]);
      idx++;
    }, 50);

    // Also hide spinner after fetch in case of errors or instant end
    setTimeout(() => {
      if (animationInterval === null) {
        document.getElementById("spinner").style.display = "none";
      }
    }, 100);
  }

</script>
</body>
</html>
